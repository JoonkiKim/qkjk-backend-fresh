두개이상의 쿼리가 동시에 여기저기서 발생할때 isolation레벨에 따라 어떤 일이 생기는지 확인해보자 

payments.service파일에 1 2 3 4 레벨을 하나씩 넣어보면서 테스트해볼거임


await queryRunner.startTransaction('READ UNCOMMITTED');
여기 코드처럼 'READ UNCOMMITTED'를 써주면 isolation레벨을 지정해줄 수 있다

1. READ UNCOMMITTED
여기서는 더러운 읽기, 반복못하는 읽기, 유령읽기가 발생하는데
특히 더러운 읽기가 발생한다!
유저1이 테이블에 5000원 충전해서 create트랜잭션을 실행하다가 실패하면 롤백이 발생함. 이게 5초가 걸린다고 해보자
근데 유저2가 그 내용을 5초안에 fetch요청한다면 레벨1에서는 롤백된 즉, UNCOMMITTED된 내용도 조회가 된다. 5초후에 또 요청을 하면 빈 값이 조회됨!
롤백된 내용은 조회가 되면 안되는데 레벨1에서는 조회가 되다가 안되는거니까 디비가 꼬이는 문제가 발생한다!


2. READ COMMITTED
여기서는 반복못하는 읽기, 유령읽기가 발생
- 반복못하는 읽기
5000원에 대한 돈 계산을 하는 트랜잭션을 시작해서 commit하는데에 3초가 걸린다고 해보자
근데 그 사이에 해당 금액에 대한 다른 금액 변경요청함수가 1초 2초 내에 동일한 트랜잭션에서 발생하면, commit되기 전인 3초이내에는 계속 동일하게 5000원이 조회되어야 한다
근데 레벨2에서는 하나의 트랜잭션에서 5000원으로 여러번 동일하게 조회되지 않는 문제가 발생한다. -> 그래서 non-repeatable read 라고 부르는거임

- 유령읽기
같은 fetch요청을 반복해서 요청하는 트랜잭션을 진행하는 중에는 누군가 create요청을 해도 commit이 안되었으므로 create요청한 값이 반영되면 안되는데, 레벨2에서는 commit되기 전에 create요청한 값이 반영된 데이터가 조회된다


* Mysql에서 기본으로 설정된 레벨은 repeatable-read로 3단계이다!
그리고 Mysql은 3단계임에도 유령읽기가 안 나타나게 내부적으로 차단해줄 수 있다! 그래서 신경 안써도 됨


// Serializable부터는 12-05의 코드를 보면서 하기
4. Serializable
4단계는 셋다 발생하지 않아서 안전하지만, 너무 느리기 때문에 특이한 케이스가 아니라면 웬만하면 쓰지 않는다. 

레벨4에는 비관적락을 사용하는데
그 안에 공유락과 배타락이 있다
공유락은 읽기 가능, 쓰기 잠금
배타락은 읽기 쓰기 모두 잠금 -> 테이블자체에 접근조차 안되게 해야된다

조회1, 조회2가 있다고 했을때 Serializable의 pessimistic_write(비관적 락)설정을 해두면
조회1의 조회가 진행되는동안 락이 걸려있고 그동안 조회2는 접근못하는 상태로 '대기'하다가 조회1의 작업이 끝나면 그때 접근하게 된다

 + where조건을 안 주면 테이블 전체에 락이 걸리는 거고 where조건으로 특정 행만 조회하면 row lock이 걸린다 -> row lock에서는 조회2가 다른 행은 조회할 수 있다


아래의 예시에서는 배타락을 사용해서 철수가 데이터를 업데이트하는동안 영희는 테이블에 접근조차 못하게 만들어줘야된다 

ex. 
이해를 돕기 위해 하나의 상황을 살펴보 겠습니다.

철수 3,000원, 훈이 2,000원, 영희 5,000원이 존재합니다.

철수와 훈이가 가진 돈을 영희에게 모두 준다고 가정해 봅시다.

그럼 우리가 생각하기로는 영희의 돈은 10,000원이 되고 끝나는 게 당연합니다.

하지만 컴퓨터의 입장에서는 순서대로 일을 진행하기에, 영희의 돈이 10,000원이 되지 않을 수도 있습니다.

**철수가 영희에게 3,000원을 주는 동시에 훈이 또한 영희에게 2,000원을 주게 된다면** 컴퓨터는 어떻게 받아들일까요?

동시에 주는 상황을 컴퓨터 입장에서 생각해 보겠습니다.

1. 영희의 돈(5,000원)을 조회 합니다.
2. 철수가 주는 3,000원을 영희의 돈으로 update 시킵니다.
3. 영희의 돈(5,000원)을 조회 합니다.
4. update가 완료되었습니다.
5. 훈이가 주는 2,000원을 영희의 돈으로 update 시킵니다.
6. update가 완료되었습니다.
7. 최종적으로 영희가 가진 돈은 7,000원이 됩니다.

즉, 위와 같은 상황은 철수가 준 돈을 update 완료 하기 전에 훈이가 돈을 넘겨줌으로써, 데이터의 오염이 일어나게 된 것입니다.

그렇기 때문에 철수가 돈을 주고 update가 완료될 때 까지는 영희 데이터에 훈이는 접근할 수 없도록 `lock`을 걸어 주셔야 합니다.





